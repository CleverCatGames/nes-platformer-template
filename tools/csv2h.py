#!/usr/bin/env python

"""
Converts CSV file to arrays in a C header file

Every CSV must have two header rows. The first is the name of the column, the second is the type.

For example:

name1,name2,name3
type1,type2,type3

Types are as follows:

name: This should always be the first column, it creates an enum using the name of the file.
u8:   An array of byte values. These can be C #defines as long as they are included first.
addr|string: An array of string or address pointers (16-bit). Different name, same function.
chr:  Creates an array that points to CHR data to be loaded by Donut with all names prefixed by chr_.
func: An array of function pointer used with LUT_CALL. Use the name of the function without parenthesis.
tileset: Generates multiple arrays for tilesets. Really only useful for the zones.csv file.
"""

import os
import argparse
import csv
import itertools

def sort_dict_lists(dct, group_by):
    names = list(dct.keys())
    names.insert(0, names.pop(names.index(group_by))) # move group_by value to front
    values = [dct[k] for k in names]
    sort_list = list(zip(*sorted(zip(*values))))
    result = {}
    for i, name in enumerate(names):
        result[name] = list(sort_list[i])
    return result

def group_offsets(values):
    group_count = {}
    last_name = None
    count = 0
    offset = 0
    for name in values:
        if last_name and name != last_name:
            group_count[last_name] = (offset, count)
            offset += count
            count = 0
        last_name = name
        count += 1
    group_count[last_name] = (offset, count)
    return group_count

def convert_to_header(filename, header):

    basename = os.path.basename(os.path.splitext(filename)[0])
    name_prefix = basename.upper().rstrip('S')

    with open(filename, 'r') as f:
        csvin = csv.reader(f)
        column_names = next(csvin)
        column_types = dict(zip(column_names, next(csvin)))
        column_values = dict((x, []) for x in column_names)

        group_by = None
        for k,v in column_types.items():
            if v == "group":
                group_by = k

        lines = list(csvin)

        # check if we have a bank line to define which bank to store the data
        if lines[0][0] == "bank":
            column_banks = dict(zip(column_names, lines[0])) # create a lookup of banks
            del column_banks['name'] # name is an enum and shouldn't have a bank
            del lines[0] # remove the bank line so it's not processed
        else:
            column_banks = {}

        for line in lines:
            if len(line) == 0 or line[0][0] == '#':
                continue  # ignore empty lines and comments

            for i, key in enumerate(column_names):
                column_values[key].append(line[i].strip())

    if group_by:
        column_values = sort_dict_lists(column_values, group_by)

    c = open(header.replace('.h', '.impl.h'), 'w')
    c.write('#include "%s"\n\n' % header.replace("../build/assets/", ""))
    with open(header, 'w') as h:
        h.write("""// Generated by csv2h.py

#ifndef {name}_H
#define {name}_H

#include "types.h"
""".format(name=name_prefix))

        def write_list(data_type, name, data_list, name_num='{}_NUM'.format(name_prefix)):
            h.write('extern const {} {}[{}];\n\n'.format(data_type, name, name_num))
            c.write('const {} {}[{}] = {{\n{}\n}};\n\n'.format(data_type, name, name_num, ',\n'.join(data_list)))

        def write_string(name, data_list):
            for string in data_list:
                h.write('extern const u8 {}[];\n'.format(string))
            write_list('u8* const', name, data_list)

        def write_chr(name, data_list):
            write_string(name, ['chr_{}'.format(v) for v in data_list])
            #write_list('u16', '{}_size'.format(name), ['chr_{}_size'.format(v) for v in data_list])

        def write_function_decl(name, data_list):
            data_list = ['%s_%s' % (name, f) for f in data_list]
            for item in set(data_list):
                h.write('void %s(void);\n' % item)
            write_list('callbackDef', '{}_routines'.format(name), data_list)

        for key in column_names:
            value_list = list(filter(None, column_values[key]))

            if key == 'name':
                # last name is <name_prefix>_NUM
                values = ',\n'.join("{}_{}".format(name_prefix, x.upper()) for x in value_list+['NUM'])
                h.write("\nenum {{\n{}\n}};\n\n".format(values))
            else:
                if key in column_banks:
                    c.write('#pragma rodata-name("{}")\n'.format(column_banks[key].upper()))

                if key in column_types:
                    value_type = column_types[key]
                else:
                    value_type = "ignore"

                if value_type == "group":
                    group_count = group_offsets(value_list)
                    offsets = []
                    global_offset = 0
                    for k,v in group_count.items():
                        offset, count = v
                        h.write('#define {}_{}_OFFSET {}\n'.format(key.upper(), k.upper(), offset - global_offset))
                        h.write('#define {}_{}_COUNT {}\n'.format(key.upper(), k.upper(), count))
                        offsets.append('{} /* {} offset */'.format(offset, k))
                        if global_offset == 0:
                            global_offset = count
                    offsets.pop(0) # remove first offset since it is always zero
                    h.write("\n")
                elif value_type == "u8":
                    write_list('u8', key, value_list)
                elif value_type == "chr":
                    write_chr(key, value_list)
                elif value_type == "tileset":
                    write_chr(key + '_tileset', value_list)
                    write_string(key + '_palette', ['palette_{}'.format(v) for v in value_list])
                    write_string(key + '_attrs', ['attrs_{}'.format(v) for v in value_list])
                    write_string(key + '_metatiles', ['metatiles_{}'.format(v) for v in value_list])
                elif value_type == "string" or value_type == "addr":
                    write_string(key, value_list)
                elif value_type == "func":
                    write_function_decl(key, value_list)

        if 'name' in column_names and 'genre' in column_names:
            for obj_type,genre in zip(column_values['name'], column_values['genre']):
                obj_type = obj_type.upper()
                h.write('#define LEVEL_OBJ_{0} (OBJECT_TYPE_{0})\n'.format(obj_type))
            h.write('\n')

        h.write('\n#endif\n')
    c.close()

def do_cli():
    parser = argparse.ArgumentParser(description='Convert object CSV to header')
    parser.add_argument('-i', '--include', action='store_true', help='Output C header file')
    parser.add_argument('obj', type=str, nargs=1, help='The object file to convert')
    parser.add_argument('h', type=str, nargs=1, help='The output header file')
    args = parser.parse_args()

    convert_to_header(args.obj[0], args.h[0])

if __name__ == "__main__":
    do_cli()

#!/usr/bin/env python

"""
Converts .lvl files and all referenced .tmx files

See the levels.lvl file for more information on the format
"""

import os
import re
import argparse
from datetime import datetime
from util.level import convert

def create_levels_header(lvl, header):
    starting_level = None
    debug_level = None
    debug_page = 0
    level_names = []
    with open(lvl, 'r') as f:
        for line in f:
            name = line.strip()
            name = re.sub("\\s?#.*$", "", name) # remove comments
            if name:
                if name.startswith('@'):
                    page = ""
                    for i,c in enumerate(name[1:]):
                        if c.isnumeric():
                            print(i, c)
                            page += c
                        else:
                            try:
                                debug_page = int(page)
                            except ValueError:
                                debug_page = 0
                            name = name[i+1:]
                            break
                    debug_level = name
                if name.startswith('>'):
                    name = name[1:]
                    starting_level = name
                level_names.append(name)

    if not starting_level:
        starting_level = level_names[0]

    # can only support 64 levels due to saving constraints
    if len(level_names) > 64:
        print("Can not have more than 64 levels!")
        exit(1)

    outdir = os.path.dirname(header)
    rootdir = 'levels'
    level_data = dict()
    tilesets = dict()
    for level in set(level_names):
        path = os.path.join(rootdir, level + '.tmx')
        header_name = level + '.h'
        outheader = os.path.join(outdir, header_name)
        if not os.path.exists(path):
            raise Exception("Level doesn't exist! " + level)
        try:
            os.makedirs(os.path.dirname(outheader))
        except FileExistsError:
            pass
        tileset, tileset_props = convert(path, outheader)
        l = os.path.split(level)
        path = os.path.join(rootdir, l[1] + '.tmx')
        p = os.path.split(path)
        tilesets[tileset] = 'update' in tileset_props and tileset_props['update'] == True
        level_data[level] = {
            'tileset': tileset,
            'bank': 'BANK_' + tileset.upper(),
            'include': '#include "{0}/{1}"'.format(rootdir, header_name)
        }

    includes = []
    banks = []
    level_ts = []
    for name in level_names:
        level = level_data[name]
        includes.append(level['include'])
        level_ts.append(level['tileset'])
        banks.append(level['bank'])
    level_names = [os.path.basename(name) for name in level_names]
    tileset_names = sorted(tilesets.keys())
    tileset_update = ['{0}_gfx_update'.format(x) if tilesets[x] else 'gfx_ignore' for x in tileset_names]

    def ts_names(name_format):
        return ',\n\t'.join([name_format.format(t) for t in tileset_names])

    with open(header.replace(".h", ".enum.h"), 'w') as f:
        f.write("""#ifndef LEVELS_ENUM_H
#define LEVELS_ENUM_H

#include "level.h"

// total number of levels
#define NUM_LEVELS {num_levels}

const callbackDef gfx_update[];

// create a constant for each level and assign a unique number
enum {{
    {level_constants}
}};

// dynamically set the starting level
#define LVL_START {starting_level}
#define LVL_DEBUG {debug_level}
#define LVL_DEBUG_PAGE {debug_page}

#endif // __LEVELS_ENUM_H__
""".format(
        num_levels=len(level_names),
        starting_level='LVL_{0}'.format(os.path.basename(starting_level).upper()),
        debug_level='LVL_{0}'.format(os.path.basename(debug_level or starting_level).upper()),
        debug_page=debug_page,
        level_constants=',\n\t'.join(['LVL_{0}'.format(name.upper()) for name in level_names]),
    ))

    with open(header, 'w') as f:
        f.write("""/**
 * Contains all data related to tilemaps and tilesets
 * Autogenerated on {today}
 * Bytes: {bytes} (for lookups, not map data)
 * Levels: {num_levels}
 * Tilesets: {num_tilesets}
 */

#ifndef LEVELS_H
#define LEVELS_H

#include "levels.enum.h"
#include "sfx.h"

// include all map data
// each file loads to different banks defined by level_banks
{includes}

#pragma rodata-name(push, "RODATA")

// this is the bank where the level is stored
const u8 level_banks[NUM_LEVELS] = {{
    {banks}
}};

// lookup for map preamble and megatile information
const u8* const level_map_info[NUM_LEVELS] = {{
    {map_info}
}};

// lookup for level objects/enemies
const u8* const level_objs[NUM_LEVELS] = {{
    {objs}
}};
#pragma rodata-name(pop)

#endif // LEVELS_H
""".format(
            today = datetime.today().strftime("%Y-%m-%d %I:%M:%S %p"),
            includes='\n'.join(includes),
            banks=',\n\t'.join(map(str, banks)),
            map_info=',\n\t'.join([l + '_map_info' for l in level_names]),
            objs=',\n\t'.join([l + '_obj' for l in level_names]),
            num_levels=len(level_names),
            num_tilesets=len(tileset_names),
            bytes=(len(level_names)*7)+(len(tileset_names)*4)
        ))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Convert levels to header format')
    parser.add_argument('lvl', type=str, nargs=1, help='The level file to convert')
    parser.add_argument('header', type=str, nargs=1, help='The output header file')
    args = parser.parse_args()

    create_levels_header(args.lvl[0], args.header[0])
